/*
This class is the Shapes class, which creates randomly placed and sized squares that do not overlap.
The squares are a key part of this program as they are the interface for the user to jam with the samples.
This class has methods are that create shapes , randomly place shapes without overlap, color & draw shapes, move shapes and interface with the SamplePlayer Class and Tick class.
A lot of this code was adapted from my Forces assignment, which was inspired by CART 353 lectures and Daniel Shiffman tutorials

*/
 

class Shapes{
  
 //declaration of PVector variables
    PVector position;
    PVector velocity;
    PVector acceleration;
    
  
   //declaration of shape variables
    float mass;
    int c;
    float x,y;
    int randomColor;
    float bpmRotate;
    boolean clicked = false;
    ArrayList<Shapes> shapes;

    //objects default constructor used to make a shallow copy
    Shapes() {
      mass = 0;
      position = new PVector(0, 0);
      velocity = new PVector(0, 0);
      acceleration = new PVector(0, 0);
      randomColor = 2;
      }
    
  
  //objects constructor that take floats for mass, position x,y and also create new PVectors for position,velocity and acceleration
    Shapes(float m, float x, float y) {
      mass = m;
      this.x =x;
      this.y =y;
      position = new PVector(x, y);
      velocity = new PVector(0, 0);
      acceleration = new PVector(0, 0);
       
      }
    
  
    
    //the massMove function is use to change the mass of the Shapes object to increase / decrease it according to the beat so we can animate it to the beat
    //if the beat is even it grows, if the beat is odd it shrinks, the beat is generated by the Tick class
   float massMove () {
       float randomSize;
         if(beat % 2 ==0) {
            randomSize = 0.3;
           } else {
             randomSize =-0.3;
           }
       return randomSize;
    }
   
   //getters and setters for x,y and mass
    void setX(float x){
      this.x = x;
    }
    
    void setY(float y){
      this.y = y;
    }
    
    void setMass(float m) {
      this.mass = m;
    }
  
    float getX() {
      return this.x;
    }
  
    float getY() {
      return this.y;
    }
    
    float getMass(){
      return this.mass;
    }
  
  
  //apply force method as we have seen in class examples
    void applyForce(PVector force) { 
      acceleration=(force);
    }
    
   
  
  //update method that applies velocity and acceleration to the shapes to create movement
    void update() {
      velocity.add(acceleration);
      position.add(velocity);
      acceleration.mult(0);
      velocity.limit(1);
      
    }
  
  
  //This method returns an arrayList filled with Shape objects, it is adapted from my code from the forces assignment which was also inspired from Daniel Shiffman tutorials
  //Shapes are created with random size and placement and they do not over lap
  
    public ArrayList<Shapes> getArrayList(int k){
      //this integer comes from the size of the string array files, so it creates the same amount of shapes as they are sample files
      int i = k;
    
    //creates new shapes ArrayList
      shapes = new ArrayList<Shapes>();
      
      //while the shapes ArrayList is smaller than the amount of files, it will run through the following code creating a full ArrayList of random non overlapping shapes
      while(shapes.size()<i) {
      
         //creates a shape with random size and position
         Shapes  s1 = new Shapes(random(40,90),random(50,width-100),random(50,height-100));  
         //sets a boolean overlap to false so we can keep track if there is an overlap
         boolean overlap = false;
         //in this for loop it creates another shape object "otherS" and gets it from the ArrayList,
         //it compares the distance from s1 shape to the otherS shape and stores it in a float d
         //if d is greater than the mass of both shapes "s1 and others1, it breaks the loop and restarts because it means both shapes overlap
         for (int j = 0; j< shapes.size(); j++) {   
           Shapes otherS = shapes.get(j);
           float d = dist(s1.getX(),s1.getY(),otherS.getX(),otherS.getY());
         
           if((d < s1.getMass() + otherS.getMass())){
             
              overlap = true;
              break;
             
            } 
            //if it passes this if statement it then checks if overlap is not the current state of the boolean which it is set to false initially
            //if it goes into this if statement it adds shape s1 to the array list, and then continues to the while loop is completed
          
         }
       
          if (!overlap) {
            shapes.add(s1); 
            
           
         }
      
      }   
      //after the arraylist is full, we can return it when calling this method
      
      return shapes;
  }
  
    //this method sets the color for each shape
    //in this program the samples are grouped together by the same color
    //the difference in the shades of colors for each group are to show that although the samples are in the same group, they are unique
    //float randomColorChange is calculated in the main by the variable shiftColor in a for loop which increments by +.25 and resets back to 0 if it proceeds 1
    //int change is to seperate samples into groups of colors, this variable also comes from the size of the string sample file name array
    
      void setColor(int change, float randomColorChange){
       
       
        int colorChange = change;
        // This is my hacky sample color detector logic, since I know the orders of the samples in the file, I can assign the samples to color groups based on this order
        //hard drums are the first samples loaded so if int change is less than 4, all the hard drums are given dark colors
        //i used the randomColorChange float so i can use processings lerpColor funciton so i can increase the shades of each color with more control than changing the RGB each time the method is called
        //i use this logic to color all the samples in groups throughout this method
        if(colorChange <4){

         int c1=color(2,2,2);
         int c2=color(99,99,99);
         c=lerpColor(c1,c2,randomColorChange);

        } 
        
        if( colorChange >=4 && colorChange<7) {
          
         int c1=color(63,255,0);
         int c2=color(21,85,0);
         c=lerpColor(c1,c2,randomColorChange);

        } 
        if( colorChange >=7 && colorChange<12) {
          
           int c1=color(143,33,255);
           int c2=color(194,134,255);
           c=lerpColor(c1,c2,randomColorChange);
         
        } 
        if (colorChange>=12) {
            int c1=color(255,103,220);
           int c2=color(255,178,237);
           c=lerpColor(c1,c2,randomColorChange);
           
        
        }
    
        
       }
  
    //display function to draw the squares
    void display() {

        rect(position.x, position.y, mass,mass,9);
        noStroke();
        fill(c);
    }
    
    //checkEdges method as we have seen in class and from Shiffman's tutorials
    //only slight modification I made is that when the squares hits and edge, it continues and comes out the opposite side, makes it less crowded and gives a continous feel to the samples
    void checkEdges() {
  
      if (position.x > width) {
        position.x = 0;
      } else if (position.x < 0) {
        position.x = width;
      }
  
      if (position.y > height-150) {
        position.y =0;
        
      }else if(position.y <0){
      position.y=height;
    }
  
    }
    
    //this method sets the boolean clicked to the boolean click that we will pass to it
    void setIsClicked (boolean click) {
      this.clicked = click;
    }
    //returns the boolean isClicked
    boolean isClicked() {
      return clicked;
    }
    
       //PlayShape method is where all the action happens
       //this method takes float d (which is calculated in the main to see the distance from the mouseX&Y position from the moving Shapes Object
       //It also takes SamplePlayer, SampleRows and old mass as parameters
       //how it works is that if the shapes object is clicked by checking the distance is smaller than the mass, the distance from the mouseX&Y,and if mouse is pressed, it sets clicked to true
       //when clicked is true it sets the sampleRow object to true, since sampleRow is a boolean array, it sets it at the first array position as i set it up in the SampleRows class
       //when this is true it stops the square from moving and calls the setMass method to change to the MassMove method, this creates the animation for the stationary to move to the jam/beat
       //if the distance of the of the object is smaller than the mass and any key pressed is true, 
       //it sets isClicked to false, which triggers the square to stop moving, return to old mass to stop animation of it "jamming" to the beat, puts the shape back in motion
       //and mutes the sample and sets the sampleRow at the first array position to false
       //clicked boolean is initially set to false so all the objects don't move or animate to the beat
       
       
    void playShape (float d, SamplePlayer sp1,  SampleRows sampleRow, float oldMass) {
  
         if (clicked) {
            PVector noMove = new PVector(0,0);
            velocity = noMove;
            acceleration = noMove;
            setMass(mass + massMove());
            }

          if( d<mass && mousePressed == true){
            setIsClicked(true); 

           }
             
          if(isClicked() ) {
              sampleRow.setSampleRow(true);
            }  
             
          if (d<mass && keyPressed == true ) {
           setIsClicked(false);
           sampleRow.setSampleRow(false);
           sp1.mute();
           setMass(oldMass);
           }  
    }
    
    
  
  }
  
    
    
    
